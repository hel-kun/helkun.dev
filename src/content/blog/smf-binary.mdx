---
title: 'SMFのバイナリを読んでみる'
description: '電通大生もすなるバイナリ解読といふものを、私もしてみむとて、するなり'
tags: ["Advent Calendar","音楽","技術"]
date: 2024-12-15
heroImage: 'https://res.cloudinary.com/helkun/image/upload/v1734065462/helkun.dev/blog/smf-binary/heroImage.png'
published: true
---
この記事は**UEC Advent Calendar 2024の15日目の記事**となります。

<UrlCard url='https://adventar.org/calendars/10127'/>

今年もその2が生えております。

<UrlCard url='https://adventar.org/calendars/10198'/>

こんにちは、へるくんです。最近、バイナリを読むのが周りで流行っているようです。[g-codeを読んでいる人](https://x.com/McbeEringi)や[pngを読んでいる人](https://x.com/McbeEringi)もいれば、[flacを読んでいる人](https://y-chan.dev/blog/reading-flac-binary/)もいますね(2/3同じ人ですが、気のせい)。

というわけで、「電通大生もすなるバイナリ解読といふものを、私もしてみむとて、するなり」という言葉もありますので、今回は流行りに乗ってバイナリを読んでみたという記事です。ついでにアウトプットがてら拙い文章で解説もしたいと思います(できるだけ噛み砕いてわかりやすくできたらと思います)。

## 何のバイナリを読むの？
今回はタイトルにもある通りSMFというファイルのバイナリを読みます。SMFはStandard Midi Fileの略で、要するにmidiに関するファイルフォーマットです。

これを読もうと思った主な理由は２つありまして、
<Box>
- midi規格書をはじめとする記事がネット上に多いため、バイナリ解読入門としてちょうど良い
- midiのピアノロールWebアプリを作る予定なのでちょうど良い
</Box>
というものがあります。あと、私はDTMが趣味なので、これを機にmidiに関する理解を深めたいというのもあります。

## 解析の準備
まず、解析をするSMFファイルを作らないとなりませんので、[Signal](https://signal.vercel.app/)というものを使用して適当に音階を打ち込んでいきます。
SignalはWeb上で動く簡易的なDAWみたいなもので、メモ程度に何か音階を打ち込みたい時にとても便利です。
今回は簡単に説明したいのでこんな感じに打ち込みました。

<ImgCard title='なんというか...こうよ！' alt='C+E+G' url='https://res.cloudinary.com/helkun/image/upload/v1733811922/helkun.dev/blog/smf-binary/signal.png'/>

なんの変哲もないCメジャーですね。

打ち込んだものを保存してエクスポートすると、`.mid`という拡張子のものができました。これがSMFファイルです。

## SMFの主な構造
まず、SMFにはFormat0, Format1, Format2の3種類のフォーマットがあります。

Format0は全てのチャンネルデータが一つのトラックにまとめられているフォーマットです。

Format1はマルチトラックフォーマットで、簡単に言えば、楽器ごとにトラックが分けられて保存されていると言えばイメージがつくと思います。おそらくこのフォーマットが最も使用されているはずですので、今回はFormat1について話していく予定です。

Format2は正直よくわからない上にあまり普及もしていないので説明は割愛します(というか、誰か教えて下さい)。
<br/>
ところで、「トラック」という音楽やってない人からするとよくわからないであろう単語が出てきました。音楽におけるトラックは、各楽器や音のデータの情報をひとつずつ分けたものです。DAWの画面でいうこれです(多分)。

<ImgCard title='枠で囲ったやつがトラックひとつ分' alt='' url='' />

<br/>
SMFのバイナリは一番最初に1つのheaderチャンク(headerに関する情報がある部分)があり、その後に複数のTrackチャンク(トラックに関する情報がある部分)が続いていくような構造が基本的です。Trackチャンクには、音階情報や後述するmetadata情報など、数々の情報が含まれています。

それでは、先ほど作ったSMFのバイナリを早速見ていきましょう。

```txt title="c.mid" frame="terminal"
4d 54 68 64 00 00 00 06 00 01 00 02 01 e0 4d 54 72 
6b 00 00 00 17 00 ff 03 00 00 ff 58 04 04 02 18 08 
00 ff 51 03 07 a1 20 00 ff 2f 00 4d 54 72 6b 00 00 
00 7f 00 b0 79 00 00 ff 03 00 00 b0 0a 40 00 b0 07 
64 00 b0 0b 7f 00 b0 65 00 00 b0 64 02 00 b0 06 40 
00 b0 65 00 00 b0 64 01 00 b0 06 40 00 b0 26 00 00 
b0 65 00 00 b0 64 00 00 b0 06 0c 00 e0 00 40 00 b0 
01 00 00 c0 00 00 90 30 64 87 40 80 30 00 00 90 34 
64 87 40 80 34 00 00 90 37 64 87 40 80 37 00 00 90 
30 64 00 90 34 64 00 90 37 64 87 40 80 30 00 00 80 
34 00 00 80 37 00 00 ff 2f 00
```

`4d 54 68 64`(utf-8に変換するとMThd)がheaderチャンク、`4d 54 72 6b`(utf-8変換するとMTrk)がTrackチャンクの開始合図となっております。
今回のバイナリを見ると、`4d 54 72 6b`がある箇所が2箇所あるため、trackは2つだということがわかります。

では、headerから順にバイナリを紐解いていきたいと思います。

## Headerのバイナリを解析してみる
header部分のバイナリはこのようになっています。
```txt title="header Chunk" frame="terminal"
4d 54 68 64 00 00 00 06 00 01 00 02 01 e0 
```
`4d 54 68 64`は先ほどもあった通り、このチャンクタイプがheaderだということを表しています。
<br/>
その後の`00 00 00 06`はheaderチャンクの長さを表しています。16進数表記である06を10進数に直しても6ですね。というわけで、この先6byte分がheaderチャンクの部分だということです。
<br/>
次は`00 01`の部分です。これはSMFのフォーマットタイプを表しています。今回はFormat1であるということがここでわかります。
<br/>
`00 02`はトラック数を表しており、今回は2トラックあることがわかります(`4d 54 72 6b`がある箇所を数えるよりも、headerのこの部分を見た方がトラックの個数はわかりやすいと思います)。
<br/>
最後の`01 e0`は1拍あたり何tickかという情報(要するに時間分解能)を表しており、今回は16進数表記である1e0を10進数に直した480tickとなっています。

ところで、いきなり「tick」というよくわからない単位が登場しました。これはとても重要な単位ですので、説明したいと思います。

## tickとは
tickというのは、1拍をさらに細かく分割した単位となってます。今回は1拍当たり480tickとなっていますので、1tickは480分の1拍となります。
<br/>
この先、Trackチャンクを紐解くにあたって、「前回のイベントから何tick後(デルタタイム)にこれこれのイベントを実行」という構造が頻繁にあります。
この時の「何tick後」を表す方法が少し特殊なので先に説明します。
<br/>
例えば、2拍後(すなわち960tick後)は、普通なら`03 c0`だと思いますが、実は違います。`87 40`と表記します。

どういうことかというと、「128\*7 + 64 = 960」という計算になります。
この「128\*7」の7に0x80を加えた値が「87」に反映されており、余りの64がもう1byte先の`40`(10進数64を16進数に直すと40)となります。

これは可変長数値表現というもので、こうすることでより長いデルタタイムを表現することが可能です。詳しくは調べてみて下さい(一応Wikipediaの記事貼っておきます)。

<UrlCard url='https://ja.wikipedia.org/wiki/%E5%8F%AF%E5%A4%89%E9%95%B7%E6%95%B0%E5%80%A4%E8%A1%A8%E7%8F%BE'/>

## Metadataを解析してみる
Trackチャンクは最初の8byteを除いて「デルタタイム + イベント」という構造が繰り返されています。

MetadataはTrackチャンクに入っており、今回は1つめのTrackチャンクにMetadataがあるので紐解いていきます。

1つめのTrackチャンクのバイナリはこのようになっています。
```txt title="Track Chunk" frame="terminal"
4d 54 72 6b 00 00 00 17 00 ff 03 00 00 ff 58 04 
04 02 18 08 00 ff 51 03 07 a1 20 00 ff 2f 00
```
`4d 54 72 6b`は先ほどから言っている通り、チャンクタイプが何かを表しています。

`00 00 00 17`はこのTrackチャンクの長さを表しており、今回はこの後に0x17 = 23byte続いていることになります。

<br/>

この後から「デルタタイム + イベント」という構造が繰り返されます。

とりあえず、`00 ff 03 00`を見てみましょう。最初の`00`はデルタタイムすなわち前回のイベントから何tick後にこの後のイベントを実行するかを表しています。
今回は0tick後ということになります。

`ff`はこのイベントがMetadataイベントであることを表しています。その後の`03`がMetadataイベントの種類を示しており、03はトラックの名前であることを表しています。



その他メタイベントの種類はこんな感じになっています。

| バイナリ | メタイベント内容 | 備考 |
| --- | --- | --- |
| `ff 00 02 ssss` | シーケンス番号 | `ssss`は上位バイトが先にストアされた16bitの値 |
| `ff 01 len text` | テキストイベント | `len`はメタイベント中でその後に続くデータ長<br/>`text`はテキストデータ |

## チャンネルコントロール

## チャンネルのノートオン、ノートオフ

## SMFのパーサを作ってnpmパッケージにしたい

## 終わりに

## 参考文献